<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cronômetro</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />

    <style>
        :root {
            color-scheme: dark;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }

        /* Fundo com DIVs (sem <img>) */
        #backgroundSlider {
            position: fixed;
            inset: 0;
            z-index: 1;
            overflow: hidden;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, .5);
        }

        .bg-slide {
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            background-size: cover;
            background-position: center center;
            filter: blur(12px) brightness(.8);
            transform: scale(1.1);
            pointer-events: none;
        }

        .bg-slide.active {
            opacity: 1;
        }

        /* Barra circular */
        .progress-circle {
            position: relative;
            width: 500px;
            height: 500px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .progress-circle svg {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .progress-circle circle {
            fill: none;
            stroke-width: 20;
            transform-origin: 50% 50%;
            transform: rotate(-90deg);
        }

        .bg-circle {
            stroke: rgba(255, 255, 255, .15);
        }

        .fg-circle {
            stroke: #fff;
            transition: stroke-dashoffset .3s linear, stroke .5s ease;
        }

        /* Tela preta final */
        #blackoutOverlay {
            z-index: 50;
            transition: opacity 1.5s ease-in-out;
        }

        /* Botão iniciar */
        #startButton {
            z-index: 10;
            background: rgba(255, 255, 255, .1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, .3);
            transition: all .3s ease;
            -webkit-user-drag: none;
        }

        #startButton:hover {
            background: rgba(255, 255, 255, .2);
            transform: scale(1.05);
        }

        /* Impedir drag de tudo */
        * {
            -webkit-user-drag: none;
        }
    </style>
</head>

<body class="flex items-center justify-center min-h-screen relative overflow-hidden" oncontextmenu="return false">
    <div id="backgroundSlider" aria-hidden="true"></div>

    <div id="blackoutOverlay" class="fixed top-0 left-0 w-full h-full bg-black hidden opacity-0"></div>

    <div id="startContainer" class="relative z-10 select-none">
        <button id="startButton"
            class="w-48 h-48 rounded-full flex items-center justify-center text-white shadow-2xl active:scale-95">
            <svg class="w-28 h-28" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"
                aria-hidden="true">
                <path fill-rule="evenodd"
                    d="M4.5 5.653c0-1.426 1.529-2.33 2.779-1.643l11.54 6.348c1.295.712 1.295 2.573 0 3.285L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653z"
                    clip-rule="evenodd" />
            </svg>
            <span class="sr-only">Iniciar cronômetro</span>
        </button>
    </div>

    <div id="timerContainer" class="hidden relative z-10 select-none" aria-live="polite">
        <div class="progress-circle">
            <svg role="img" aria-label="Progresso do tempo">
                <circle class="bg-circle" cx="50%" cy="50%" r="230"></circle>
                <circle id="fgCircle" class="fg-circle" cx="50%" cy="50%" r="230"></circle>
            </svg>
            <div id="timer" class="absolute font-orbitron text-[7rem] font-bold text-white">00:00</div>
        </div>
    </div>

    <script>
        // ======= CONFIG =======
        const TARGET_HOUR = 19;    // 19:45
        const TARGET_MIN = 45;
        const TARGET_SEC = 0;

        // ======= DOM =======
        const backgroundSlider = document.getElementById('backgroundSlider');
        const blackoutOverlay = document.getElementById('blackoutOverlay');
        const startContainer = document.getElementById('startContainer');
        const startButton = document.getElementById('startButton');
        const timerContainer = document.getElementById('timerContainer');
        const timerDisplay = document.getElementById('timer');
        const fgCircle = document.getElementById('fgCircle');

        // ======= STATE =======
        let timeInSeconds = 0;
        let totalAtStart = 1; // evita divisão por zero
        let countdownInterval;
        let isRunning = false;

        // círculo
        const radius = fgCircle.r.baseVal.value;
        const circumference = 2 * Math.PI * radius;
        fgCircle.style.strokeDasharray = `${circumference} ${circumference}`;
        fgCircle.style.strokeDashoffset = circumference;

        // imagens como background em DIV (sem <img>)
        const backgroundImages = [
            'https://cms-imgp.jw-cdn.org/img/p/2022681/univ/art/2022681_univ_cnt_2_lg.jpg',
            'https://cms-imgp.jw-cdn.org/img/p/2022681/univ/art/2022681_univ_cnt_4_xl.jpg',
            'https://cms-imgp.jw-cdn.org/img/p/1102025973/univ/art/1102025973_univ_cnt_1_xl.jpg',
            'https://cms-imgp.jw-cdn.org/img/p/1102025973/univ/art/1102025973_univ_cnt_7_xl.jpg'
        ];
        let currentImageIndex = 0;

        function loadBackgroundImages() {
            backgroundImages.forEach((src, index) => {
                const slide = document.createElement('div');
                slide.className = 'bg-slide' + (index === 0 ? ' active' : '');
                slide.style.backgroundImage = `url('${src}')`;
                backgroundSlider.appendChild(slide);
            });

            setInterval(() => {
                const slides = backgroundSlider.children;
                if (!slides.length) return;
                slides[currentImageIndex]?.classList.remove('active');
                currentImageIndex = (currentImageIndex + 1) % slides.length;
                slides[currentImageIndex]?.classList.add('active');
            }, 8000);
        }

        function setProgress(percent) {
            const clamped = Math.max(0, Math.min(100, percent));
            const offset = circumference - (clamped / 100) * circumference;
            fgCircle.style.strokeDashoffset = offset;
        }

        function formatMMSS(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        function getSecondsUntilTodayTarget() {
            const now = new Date();
            const target = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate(),
                TARGET_HOUR,
                TARGET_MIN,
                TARGET_SEC,
                0
            );
            const diffMs = target.getTime() - now.getTime();
            return Math.max(0, Math.floor(diffMs / 1000));
        }

        function updateDisplay() {
            timerDisplay.textContent = formatMMSS(timeInSeconds);

            const percent = (timeInSeconds / totalAtStart) * 100;
            setProgress(percent);

            fgCircle.classList.remove('stroke-white', 'stroke-yellow-300', 'stroke-red-500');
            if (timeInSeconds <= 10) fgCircle.classList.add('stroke-red-500');
            else if (timeInSeconds <= 60) fgCircle.classList.add('stroke-yellow-300');
            else fgCircle.classList.add('stroke-white');
        }

        function showBlackout() {
            timerContainer.classList.add('hidden');
            blackoutOverlay.classList.remove('hidden');
            requestAnimationFrame(() => blackoutOverlay.classList.remove('opacity-0'));
        }

        function tryClosePage() {
            try { window.close(); } catch (_) { }
        }

        function finishAndClose() {
            clearInterval(countdownInterval);
            isRunning = false;
            showBlackout();
            setTimeout(tryClosePage, 700);
        }

        function resetApp() {
            clearInterval(countdownInterval);
            isRunning = false;

            timeInSeconds = getSecondsUntilTodayTarget();
            totalAtStart = Math.max(1, timeInSeconds);

            updateDisplay();
            blackoutOverlay.classList.add('hidden', 'opacity-0');
            timerContainer.classList.add('hidden');
            startContainer.classList.remove('hidden');
        }

        // ======= FULLSCREEN "SAFE" =======
        async function requestFullscreenSafe() {
            try {
                if (document.fullscreenElement) return;
                if (document.documentElement.requestFullscreen) {
                    await document.documentElement.requestFullscreen();
                }
            } catch (_) {
                // pode ser bloqueado sem gesto do usuário
            }
        }

        // arma o fullscreen: no primeiro clique/tecla na janela, entra em tela cheia
        function armFullscreenOnFirstUserGesture() {
            const handler = async () => {
                cleanup();
                await requestFullscreenSafe();
            };

            const cleanup = () => {
                window.removeEventListener('pointerdown', handler, true);
                window.removeEventListener('keydown', handler, true);
                window.removeEventListener('touchstart', handler, true);
            };

            window.addEventListener('pointerdown', handler, true);
            window.addEventListener('keydown', handler, true);
            window.addEventListener('touchstart', handler, true);
        }

        // ======= SEGUNDA TELA (quando disponível) =======
        function isAutostartWindow() {
            const p = new URLSearchParams(location.search);
            return p.get('autostart') === '1';
        }

        function isPopupWindow() {
            const p = new URLSearchParams(location.search);
            return p.get('popup') === '1';
        }

        async function openOnSecondScreenIfPossible() {
            if (isPopupWindow()) return false; // evita loop

            const baseUrl = new URL(location.href);
            baseUrl.searchParams.set('popup', '1');
            baseUrl.searchParams.set('autostart', '1');

            // 1) Window Placement API (se disponível e permitido)
            if ('getScreenDetails' in window) {
                try {
                    const details = await window.getScreenDetails();
                    if (details?.screens?.length > 1) {
                        const current = details.currentScreen;
                        const second = details.screens.find(s => s !== current) || details.screens[1];

                        const left = Math.round(second.availLeft ?? second.left ?? 0);
                        const top = Math.round(second.availTop ?? second.top ?? 0);
                        const width = Math.round(second.availWidth ?? second.width ?? 1280);
                        const height = Math.round(second.availHeight ?? second.height ?? 720);

                        const win = window.open(
                            baseUrl.toString(),
                            'cronometro_second_screen',
                            `popup=yes,left=${left},top=${top},width=${width},height=${height}`
                        );

                        if (win) {
                            try { win.focus(); } catch (_) { }
                            try { window.close(); } catch (_) { }
                            return true;
                        }
                    }
                } catch (_) { }
            }

            // 2) Fallback simples
            try {
                const approxLeft = (window.screenX || 0) + (window.outerWidth || 1200);
                const approxTop = (window.screenY || 0);

                const win = window.open(
                    baseUrl.toString(),
                    'cronometro_second_screen',
                    `popup=yes,left=${approxLeft},top=${approxTop},width=${window.outerWidth || 1200},height=${window.outerHeight || 800}`
                );

                if (win) {
                    try { win.focus(); } catch (_) { }
                    try { window.close(); } catch (_) { }
                    return true;
                }
            } catch (_) { }

            return false;
        }

        // ======= TIMER =======
        async function startTimer() {
            if (isRunning) return;

            const moved = await openOnSecondScreenIfPossible();
            if (moved) return; // a outra janela vai autostartar

            timeInSeconds = getSecondsUntilTodayTarget();
            totalAtStart = Math.max(1, timeInSeconds);

            if (timeInSeconds <= 0) {
                startContainer.classList.add('hidden');
                timerContainer.classList.remove('hidden');
                updateDisplay();
                finishAndClose();
                return;
            }

            await requestFullscreenSafe();

            startContainer.classList.add('hidden');
            timerContainer.classList.remove('hidden');
            isRunning = true;

            updateDisplay();

            countdownInterval = setInterval(() => {
                timeInSeconds--;
                updateDisplay();
                if (timeInSeconds <= 0) finishAndClose();
            }, 1000);
        }

        // ======= EVENTOS =======
        startButton.addEventListener('click', startTimer);

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && isRunning) resetApp();
        });

        // ======= BLOQUEIOS (mais fortes contra "arrastar html") =======
        document.addEventListener('dragstart', e => e.preventDefault(), true);
        document.addEventListener('drop', e => e.preventDefault(), true);
        document.addEventListener('selectstart', e => e.preventDefault(), true);

        // impede “arrasto”/seleção enquanto o timer estiver rodando (evita o ícone "html" no macOS)
        document.addEventListener('mousedown', (e) => {
            if (isRunning) e.preventDefault();
        }, { passive: false });

        document.addEventListener('mousemove', (e) => {
            if (isRunning && (e.buttons & 1)) e.preventDefault();
        }, { passive: false });

        // Bloqueios “soft”
        document.addEventListener('copy', e => e.preventDefault());
        document.addEventListener('cut', e => e.preventDefault());
        document.addEventListener('keydown', e => {
            const k = e.key?.toLowerCase();
            if ((e.ctrlKey || e.metaKey) && ['s', 'p', 'u', 'c', 'i', 'j'].includes(k)) e.preventDefault();
            if (k === 'f12') e.preventDefault();
        });

        // ======= INICIALIZAÇÃO =======
        loadBackgroundImages();
        resetApp();

        if (isAutostartWindow()) {
            armFullscreenOnFirstUserGesture();
            setTimeout(() => startTimer(), 50);
        }
    </script>
</body>

</html>